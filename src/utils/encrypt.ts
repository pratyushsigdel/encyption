// Body should be encrypted using AES
// key used to decrypt body should be encrypted using RSA
// aadhaar Card details should be encrypted using tripleDES

//

// import JSEncrypt from "jsencrypt";
// import CryptoJS from "crypto-js";

// // Generate a random AES key (16 bytes)
// // the aes key should be generated by backend
// export const generateAESKey = () => {
//     const array = new Uint8Array(16);
//     crypto.getRandomValues(array);

//     console.log(
//         Array.from(array)
//             .map((b) => b.toString(16).padStart(2, "0"))
//             .join("")
//     );
//     return Array.from(array)
//         .map((b) => b.toString(16).padStart(2, "0"))
//         .join("");
// };

// // Generate a random IV
// export const generateIV = () => {
//     const array = new Uint8Array(16);
//     crypto.getRandomValues(array);
//     return Array.from(array)
//         .map((b) => b.toString(16).padStart(2, "0"))
//         .join("");
// };

// // Encrypt the AES key with RSA
// export const encryptKey = (data: string, publicKeyPEM: string) => {
//     const encrypt = new JSEncrypt();
//     encrypt.setPublicKey(publicKeyPEM);
//     return encrypt.encrypt(data);
// };

// // Decrypt the AES key using RSA
// export const decryptKey = (encryptedKey: string, privateKeyPEM: string) => {
//     const decrypt = new JSEncrypt();
//     decrypt.setPrivateKey(privateKeyPEM);
//     return decrypt.decrypt(encryptedKey);
// };

// // Encrypt the body data using AES
// export const encryptBody = (input:string, key:string,) => {
//     const cipherText = CryptoJS.AES.encrypt(input, CryptoJS.enc.Utf8.parse(key), {
        
//         mode: CryptoJS.mode.CBC,
//         padding: CryptoJS.pad.Pkcs7,
//     });
//     return cipherText.toString();
// };

// // Decrypt the body data using AES
// export const decryptBody = (cipherText: string, key: string,) => {
//     const bytes = CryptoJS.AES.decrypt(cipherText, CryptoJS.enc.Utf8.parse(key), {
     
//         mode: CryptoJS.mode.CBC,
//         padding: CryptoJS.pad.Pkcs7,
//     });
//     return bytes.toString(CryptoJS.enc.Utf8);
// };

import JSEncrypt from "jsencrypt";
import CryptoJS from "crypto-js";

// Derive IV from AES key â€” both sides compute same IV without transmitting it
const deriveIV = (key: string) => {
    return CryptoJS.enc.Utf8.parse(key.substring(0, 16));
};

// Generate a random AES key (16 bytes)

export const generateAESKey = () => {
    const array = new Uint8Array(16);
    crypto.getRandomValues(array);
    return Array.from(array)
        .map((b) => b.toString(16).padStart(2, "0"))
        .join("");
};

// Encrypt the AES key with RSA
export const encryptKey = (data: string, publicKeyPEM: string) => {
    const encrypt = new JSEncrypt();
    encrypt.setPublicKey(publicKeyPEM);
    return encrypt.encrypt(data);
};

// Decrypt the AES key using RSA
export const decryptKey = (encryptedKey: string, privateKeyPEM: string) => {
    const decrypt = new JSEncrypt();
    decrypt.setPrivateKey(privateKeyPEM);
    return decrypt.decrypt(encryptedKey);
};

// Encrypt the body data using AES

export const encryptBody = (input: string, key: string) => {
    return CryptoJS.AES.encrypt(
        input,
        CryptoJS.enc.Utf8.parse(key),
        {
            iv: deriveIV(key),        
            mode: CryptoJS.mode.CBC,
            padding: CryptoJS.pad.Pkcs7,
        }
    ).toString();
};

// Decrypt the body data using AES

export const decryptBody = (cipherText: string, key: string) => {
    const bytes = CryptoJS.AES.decrypt(
        cipherText,
        CryptoJS.enc.Utf8.parse(key),
        {
            iv: deriveIV(key),      
            mode: CryptoJS.mode.CBC,
            padding: CryptoJS.pad.Pkcs7,
        }
    );
    return bytes.toString(CryptoJS.enc.Utf8);
};
